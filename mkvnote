#!/usr/bin/env bash

# ================================
# Script: mkvnote
# Purpose: GUI tool for editing MKV metadata tags
# Focus: NMAAHC archival standards
# ================================

# ================================
# Section 1: Configuration and Constants
# ================================

# ================================
# Section 1.1: Tag Set Definitions
# ================================
MKV_TAG_SET_NMAAHC=(
    "COLLECTION"
    "TITLE"
    "CATALOG_NUMBER" 
    "DESCRIPTION"
    "DATE_DIGITIZED"
    "ENCODER_SETTINGS"
    "ENCODED_BY"
    "ORIGINAL_MEDIA_TYPE"
    "DATE_TAGGED"
    "_TAGGED_BY"
    "TERMS_OF_USE"
    "_PRE_TRANSFER_NOTES"
    "_TRANSFER_NOTES"
    "_ORIGINAL_FPS"
)

# ================================
# Section 1.2: Read Only and Special Tag Configuration
# ================================
RO_TAGS=("ENCODER" "VIDEO_STREAM_HASH" "AUDIO_STREAM_HASH")
MULTILINE_TAGS=("DESCRIPTION" "ENCODER_SETTINGS" "_PRE_TRANSFER_NOTES" "_TRANSFER_NOTES")

# ================================
# Section 1.3: GUI Field Height Configuration
# ================================
declare -A FIELD_HEIGHTS=(
    ["DESCRIPTION"]="105"
    ["ENCODER_SETTINGS"]="90"
    ["_PRE_TRANSFER_NOTES"]="30"
    ["_TRANSFER_NOTES"]="30"
)

# ================================
# Section 2: Terminal Color Definitions
# ================================
BOLD=$(tput bold); RESET=$(tput sgr0); DIM=$(tput dim)
ERROR=$(tput setaf 1); GREEN=$(tput setaf 2); YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4); MAGENTA=$(tput setaf 5); CYAN=$(tput setaf 6); WHITE=$(tput setaf 7)

# ================================
# Section 3: Help and Usage Functions
# ================================

# ================================
# Section 3.1: Version Information
# ================================
VERSION="1.0.0"
SCRIPT_NAME=$(basename "$0")

# ================================
# Section 3.3: Help Menu Function
# ================================
_show_help() {
    cat << EOF

${BOLD}${CYAN}╔══════════════════════════════════════════════════════════════════════════════╗
║                    mkvnote - Matroska Metadata Editor                        ║
╚══════════════════════════════════════════════════════════════════════════════╝${RESET}

${BOLD}DESCRIPTION${RESET}
    GUI tool for editing MKV file metadata tags according to NMAAHC archival
    standards. Provides a GTK interface for viewing and modifying tags embedded
    in Matroska video files.

    mkvnote accepts either a <mkv_file> or <csv_file> as an input. If an mkv file
    is used then a data entry GUI window will open. If a csv is used, the mkvnote
    will embed the metadata of the csv into the associated mkv files. Note that
    with a csv input the first column must be 'filename' and contain a path to
    the associated mkv file.

${BOLD}USAGE${RESET}
    ${GREEN}\$${RESET} ${SCRIPT_NAME} [-c|-i|-d] <mkv_file>
    ${GREEN}\$${RESET} ${SCRIPT_NAME} <csv_file>
    ${GREEN}\$${RESET} ${SCRIPT_NAME} [options]

${BOLD}OPTIONS${RESET}
    ${CYAN}-h, --help${RESET}            Show this help message and exit
    ${CYAN}-v, --version${RESET}         Show version information and exit

${BOLD}TAG CATEGORIES${RESET}
    ${MAGENTA}Read-Only (Technical):${RESET}
        ENCODER, VIDEO_STREAM_HASH, AUDIO_STREAM_HASH, ATTACHMENTS

    ${MAGENTA}NMAAHC Standard Tags:${RESET}
        COLLECTION, TITLE, CATALOG_NUMBER, DESCRIPTION, DATE_DIGITIZED,
        ENCODER_SETTINGS, ENCODED_BY, ORIGINAL_MEDIA_TYPE, DATE_TAGGED,
        _TAGGED_BY, TERMS_OF_USE, _PRE_TRANSFER_NOTES, _TRANSFER_NOTES,
        _ORIGINAL_FPS

${BOLD}OUTPUT${RESET}
    On save, creates a JSON sidecar file: ${CYAN}<filename>_mkvnote_tags.json${RESET}

${BOLD}EXAMPLES${RESET}
    ${GREEN}\$${RESET} ${SCRIPT_NAME} video.mkv
    ${GREEN}\$${RESET} ${SCRIPT_NAME} /path/to/archive/preservation_master.mkv
    ${GREEN}\$${RESET} ${SCRIPT_NAME} --help

${BOLD}ADDITIONAL OPTIONS${RESET}

${CYAN}-c|--csv${RESET} matroska input and csv output

    To produce a csv output from a list of mkv files:
    ${GREEN}\$${RESET} ${SCRIPT_NAME} -c file1.mkv file2.mkv file3.mkv > my.csv

    The output can then be edited to write back into the source files with "$(basename "${0}") my.csv"

${CYAN}-i|--info${RESET} print info about each file

    To print information about the global tags in each matroska file:

    ${GREEN}\$${RESET} ${SCRIPT_NAME} -i file1.mkv file2.mkv file3.mkv

${CYAN}-d|--drop${RESET} delete the global tags

    This option is mostly used for debugging. It will remove all global tags (except the ffmpeg ENCODER
    tag) from all input mkv files. Warning this is a destructive, irreversible process.

${BOLD}DEPENDENCIES${RESET}
    Required: mkvtoolnix (mkvpropedit, mkvextract), gtkdialog, xmlstarlet,
              mediainfo, perl
    macOS:    XQuartz (for GTK display)

${BOLD}ABOUT${RESET}
    Developed by Smithsonian NMAAHC in collaboration with Dave Rice
    ${DIM}https://github.com/NMAAHC/nmaahcmm${RESET}

EOF
}

# ================================
# Section 3.4: Version Function
# ================================
_show_version() {
    echo "${SCRIPT_NAME} version ${VERSION}"
    echo "Matroska Metadata Editor for NMAAHC archival standards"
}

# ================================
# Section 3.5: Usage Function (Brief)
# ================================
_show_usage(){
    cat <<EOF

    ${SCRIPT_NAME}

    This application will embed key:value pairs ("tags") into a Matroska file.
   
    "${BOLD}Usage:${RESET} ${SCRIPT_NAME} <mkv_file>"

    To open a metadata editor GUI for the mkv_file, or

    "${BOLD}Usage:${RESET} ${SCRIPT_NAME} <my_csv_of_metadata.csv>"

    to batch-embed metadata from a csv into a set of files (the first column of the csv must be 'filename' and contain the path to the mkv file)

    ${DIM}Use -h or --help for detailed information and additional options${RESET}
EOF
exit
}

# ================================
# Section 4: Core Utility Functions
# ================================

# ================================
# Section 4.1: Dependency Validation
# ================================
_check_dependencies(){
    local DEPS_OK=YES
    for DEP in "$@"; do
        command -v "${DEP}" >/dev/null 2>&1 || { echo "${ERROR}✗${RESET} Missing: ${BOLD}${DEP}${RESET}"; DEPS_OK=NO; }
    done
    [[ "${DEPS_OK}" = "NO" ]] && { echo "${ERROR}Installation required. Exiting...${RESET}"; exit 1; }
}

# ================================
# Section 4.2: File and Text Processing Utilities
# ================================
_maketemp(){ mktemp -q -t "$(basename "$0")" || { echo "${ERROR}Can't create temp file${RESET}"; exit 1; }; }
_temprm(){ RM_FILE="${1}" ; if [[ -f "${RM_FILE}" ]] ; then rm "${RM_FILE}" ; fi }
_in_list(){ local item="$1"; shift; for x in "$@"; do [[ "$x" == "$item" ]] && return 0; done; return 1; }

_check_dependencies csvprintf xmlstarlet mkvpropedit mkvextract xml2csv

# Handle no arguments
if [[ $# -eq 0 ]]; then
    echo "${ERROR}✗ No input file provided${RESET}"
    _show_usage
    exit 1
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            _show_help
            exit 0
            ;;
        -v|--version)
            _show_version
            exit 0
            ;;
        -c|--csv)
            MKV2CSV="Y"
            MULTI_INPUT_OK="yes"
            ;;
        -i|--info)
            MKVINFO="Y"
            MULTI_INPUT_OK="yes"
            ;;
        -d|--drop)
            MKVGLOBALRM="Y"
            MULTI_INPUT_OK="yes"
            ;;
        -*)
            echo "${ERROR}✗ Unknown option: $1${RESET}"
            _show_usage
            exit 1
            ;;
        *)
            # If extra options, let's check to make sure they're files
            if [[ ! -f "${1}" ]]; then
                echo "${ERROR}✗ ${1} is expected to be a file, but it's not.${RESET}"
                _show_usage
                exit 1
            else
                break
            fi
            ;;
    esac
    shift
done

if [[ "${#}" -eq 0 ]]; then
    _show_usage
fi

INPUT_FILE="${1}"
EXTENSION="${INPUT_FILE##*.}"

if [[ -z "${INPUT_FILE}" ]]; then
    echo "${ERROR}✗ No input file provided${RESET}"
    _show_usage
    exit 1
fi

if [[ ! -f "${INPUT_FILE}" ]]; then
    echo "${ERROR}✗ File not found: ${INPUT_FILE}${RESET}"
    exit 1
fi

if [[ ! "${INPUT_FILE}" =~ \.[Mm][Kk][Vv]$ && ! "${MKV2CSV}" = "Y" ]]; then
    echo "${YELLOW}! Warning: File does not have .mkv extension${RESET}"
fi

if [[ "${EXTENSION}" == "csv" ]] ; then
    CSV_XML="$(_maketemp).xml"
    csvprintf -X -f "${INPUT_FILE}" > "${CSV_XML}"
    ELEMENT_LIST="$(xmlstarlet sel -t -m "/csv/row[1]/*" -v "name()" -n "${CSV_XML}")"
    FILENAME_FOUND=0
    echo "Examining the csv: ${CSV_XML}."
    while read ELEMENT_VALUE ; do
        if [[ "${ELEMENT_VALUE//_}" == "filename" ]] ; then
            FILENAME_COLUMN_NAME="${ELEMENT_VALUE}"
            ELEMENT_VALUE="filename"
        fi
        echo "Found ${ELEMENT_VALUE}."
        ADDITIONAL_COLUMNS+="_${ELEMENT_VALUE}"
        if [[ "${ELEMENT_VALUE}" == "filename" ]] ; then
            FILENAME_FOUND=1
        fi
    done < <(echo "${ELEMENT_LIST}")

    if [[ "${FILENAME_FOUND}" = "0" ]] ; then
        echo "${BOLD}${ERROR}Error, $(basename "${INPUT_FILE}") does not contain a column called 'filename'. Exiting.${RESET}"
        exit
    fi

    MISSING_FILE=0
    REPEATED_FILENAMES="$(xmlstarlet sel -t -m "/csv/row/___filename" -v . -n  "${CSV_XML}" | sort | uniq -c | grep -v "^ *1 ")"
    if [[ -n "${REPEATED_FILENAMES}" ]] ; then
        echo "${BOLD}${ERROR}Error, ${INPUT_FILE} contains multiple iterations of the same filename.${RESET}"
        echo "${REPEATED_FILENAMES}"
        echo "${BOLD}${ERROR}Comee back when it's fixed.${RESET}"
        exit 1
    fi
    ROW_COUNTER=1
    while read FILE_IN_CSV ; do
        ((ROW_COUNTER++))
        if [[ -z "${FILE_IN_CSV}" ]] ; then
            echo "${BOLD}${ERROR}Warning, the filename column on row ${ROW_COUNTER} is empty.${RESET}"
        elif [[ ! -f "${FILE_IN_CSV}" ]] ; then
            echo "${BOLD}${ERROR}Error, $(basename "${FILE_IN_CSV}") is referenced in the csv but not found.${RESET}"
            MISSING_FILE=1
            MISSING_FILE_LIST+="${FILE_IN_CSV} "
        fi
    done < <(xmlstarlet sel -t -m "/csv/row/${FILENAME_COLUMN_NAME}" -v . -n "${CSV_XML}")
    if [[ -z "${FILENAME_COLUMN_NAME}" ]] ; then
        FILENAME_COLUMN_NAME="filename"
    fi
    if [[ "${MISSING_FILE}" != "0" ]] ; then
        echo "${BOLD}${ERROR}Error, Some files in the csv, such as ${MISSING_FILE_LIST}, are not found. Exiting.${RESET}"
        exit
    else
        echo "${BOLD}Nice. All files from the csv are found. Let's tag.${RESET}"
    fi
    while read FILE_IN_CSV ; do
        XML_DRAFT="$(_maketemp).xml"
        mkvextract tags "${FILE_IN_CSV}" > "${XML_DRAFT}"
        EXISTING_TAGS="$(xmlstarlet sel -t -m '/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple/Name' -v . -n "${XML_DRAFT}" | awk '!seen[$0]++')"
        echo "${BOLD}Tagging ${FILE_IN_CSV} with: ${RESET}"
        echo "---------------------|---------------------"

        while read TAG_NAME ; do
            TAG_VALUE="$(xmlstarlet sel -t -m "/csv/row[${FILENAME_COLUMN_NAME}='${FILE_IN_CSV}']/${TAG_NAME}" -v "." -n "${CSV_XML}")"
            if [[ "${TAG_NAME//_}" == "filename" ]] ; then
                TAG_NAME="filename"
            fi

            if ! xmlstarlet sel -t -m '/Tags/Tag[not(Targets) or count(Targets/*)=0]' -v '.' -n "${XML_DRAFT}" | grep -q . ; then
              xmlstarlet ed -P -L \
                -s '/Tags' -t elem -n 'Tag' \
                -s '/Tags/Tag[last()]' -t elem -n 'Targets' \
                "${XML_DRAFT}"
              echo "Added a new <Tag> with empty <Targets> with ${FILE_IN_CSV}."
            fi

            if [[ -n "${TAG_VALUE// /}" && "${TAG_NAME//_}" != "filename" ]] ; then
                if echo "${EXISTING_TAGS}" | grep -Fxq "${TAG_NAME}"; then
                    xml ed --omit-decl -P --inplace \
                        --update "(/Tags/Tag[Simple/Name='${TAG_NAME}'])[last()]/Simple[Name='${TAG_NAME}']/String" -v "${TAG_VALUE}" \
                        "${XML_DRAFT}"
                else
                    xml ed --omit-decl --inplace \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]" --type elem -n "Simple" \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple[not(Name)]" --type elem -n "Name" -v "${TAG_NAME}" \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple[not(String)]" --type elem -n "String" -v "${TAG_VALUE}" \
                        "${XML_DRAFT}"
                fi
            fi
            printf "%-22s" "$TAG_NAME"
            echo "$TAG_VALUE" | sed '1n; s/^/                      /'

        done < <(xmlstarlet sel -t -m "/csv/row[${FILENAME_COLUMN_NAME}='${FILE_IN_CSV}']/*[normalize-space(.) != '']" -v "name()" -n "${CSV_XML}")
        echo

        mkvpropedit --tags "all:${XML_DRAFT}" "${FILE_IN_CSV}"

    done < <(xmlstarlet sel -t -m "/csv/row/${FILENAME_COLUMN_NAME}" -v . -n "${CSV_XML}")

    exit
fi

if [[ "${MKV2CSV}" == "Y" ]] ; then
    INPUT_FILES=("$@")
    while [[ "${@}" != "" ]] ; do
        INPUT_FILE="${1}"
        shift
        EXTRACTED_TAGS="$(_maketemp).xml"
        XML_DRAFT="$(_maketemp).xml"
        mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
        TAGS_FOUND+="$(xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple" -v "Name" -n "${EXTRACTED_TAGS}")"$'\n'
    done
    UNIQUE_TAGS="$(awk 'NF && !seen[$0]++' <<< "$TAGS_FOUND")"

    CSV_XML="$(_maketemp).xml"
    echo "<csv/>" > "${CSV_XML}"
    for INPUT_FILE in "${INPUT_FILES[@]}"; do
        XML_ED_INSTRUCTIONS=()
        EXTRACTED_TAGS="$(_maketemp).xml"
        mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
        while read UNIQUE_TAG ; do
            UNIQUE_TAG_VALUE="$(xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple[Name='${UNIQUE_TAG}']" -v "String" -n "${EXTRACTED_TAGS}")"
            if [[ "${UNIQUE_TAG}" == "${UNIQUE_TAG// /}" ]] ; then
                XML_ED_INSTRUCTIONS+=(--subnode "/csv/row[not(${UNIQUE_TAG})]" --type elem -n "${UNIQUE_TAG}" -v "${UNIQUE_TAG_VALUE}")
            else
                echo "${BOLD}${ERROR}Warning, ${INPUT_FILE} contains a TagName of '${UNIQUE_TAG}'; however TagName is not allowed to contain a space. This value will be ignored while making the csv. See ${EXTRACTED_TAGS} for the tag structure of this file if you like.${RESET}" >&2
            fi
        done <<< "${UNIQUE_TAGS}"

        xml ed --omit-decl --inplace \
            --subnode "/csv" --type elem -n "row" \
            --subnode "/csv/row[not(filename)]" --type elem -n "filename" -v "${INPUT_FILE}" "${XML_ED_INSTRUCTIONS[@]}" "${CSV_XML}"
        EXTRACTED_TAGS="$(_maketemp).txt"
        XML_DRAFT="$(_maketemp).xml"
    done
    CSV_HEADER=$(xmlstarlet sel -t -m "/csv/row[1]/*" -v "name()" -o "," "${CSV_XML}" | sed 's/,$//')
    echo "${CSV_HEADER}"
    xml2csv "${CSV_XML}"
    exit
fi

if [[ "$MKVINFO" == "Y" ]] ; then
    INPUT_FILES=("$@")
    while [[ "${@}" != "" ]] ; do
        # get context about the input
        INPUT_FILE="${1}"
        shift
        echo "Global tag report for: ${INPUT_FILE}"
        echo "---------------------|---------------------"
        mkvextract tags "${INPUT_FILE}" | xmlstarlet sel -t -m "Tags/Tag[not(Targets) or count(Targets/*)=0]" -m Simple  -v Name -o $'\t' -v String -o $'\037' | awk -v RS=$'\037' -F'\t' '{n = split($2, lines, /\r?\n/); printf "%-21s %s\n", $1, lines[1]; for(i=2; i<=n; i++) printf "%-21s %s\n", "", lines[i]; }' 
        mkvextract tags "${INPUT_FILE}" | xmlstarlet sel -t -m "Tags/Tag[not(Targets) or count(Targets/*)=0]" -o "Tag:" -n  -m Simple -o " " -v Name -o "=(" -v String -o ")" -n 
        echo
    done
    exit
fi

if [[ "$MKVGLOBALRM" == "Y" ]] ; then
    INPUT_FILES=("$@")
    echo "This process will delete all the global tags in all the input files. Are you sure? Type 'Y' to proceed, anything else to quit."
    read -p "Really? " DELETE_CHOICE
    if [[ "${DELETE_CHOICE}" =~ ^[Yy]$ ]] ; then
        while [[ "${@}" != "" ]] ; do
            INPUT_FILE="${1}"
            shift
            echo "Deleting global tags for ${INPUT_FILE}..."
            TEMP_XML="$(_maketemp).xml"
            mkvextract tags out2.mkv | xmlstarlet ed -d "//Tag[Targets/*]" -d '//Simple[Name != "ENCODER"]' > "${TEMP_XML}"
            mkvpropedit --tags "global:" "${INPUT_FILE}"
            mkvpropedit --tags "global:${TEMP_XML}" "${INPUT_FILE}"
        done
        _temprm "${TEMP_XML}"
        echo "Thx. Global tags are gone now from $(basename "${INPUT_FILE}")."
    else
        echo "np"
    fi
    exit
fi

# ================================
# Section 4.3: Attachment Processing
# ================================
_get_attachments() {
    local INPUT_FILE="$1"
    local ATTACHMENT_INFO
    
    # Try to get attachment info using mkvextract
    ATTACHMENT_INFO=$(mkvextract attachments "${INPUT_FILE}" 2>/dev/null | grep "^File name:" | cut -d: -f2- | sed 's/^ *//')
    
    # If mkvextract doesn't work or no attachments found, try mediainfo
    if [[ -z "${ATTACHMENT_INFO}" ]]; then
        ATTACHMENT_INFO=$(mediainfo --Output="General;%Attachments%" "${INPUT_FILE}" 2>/dev/null)
    fi
    
    # Parse and format attachment names
    if [[ -n "${ATTACHMENT_INFO}" && "${ATTACHMENT_INFO}" != "N/A" ]]; then
        # Handle different formats - mediainfo uses " / " separator
        if echo "${ATTACHMENT_INFO}" | grep -q " / "; then
            echo "${ATTACHMENT_INFO}" | sed 's/ \/ / ; /g'
        else
            # Handle newline-separated format from mkvextract
            echo "${ATTACHMENT_INFO}" | tr '\n' ';' | sed 's/;$//; s/;/ ; /g'
        fi
    else
        echo "none"
    fi
}

EXISTING_TAGS="$(_maketemp).txt"
EXTRACTED_TAGS="$(_maketemp).txt"
XML_DRAFT="$(_maketemp).xml"

mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple" -v "Name" -n "${EXTRACTED_TAGS}" >> "${EXISTING_TAGS}"

ATTACHMENT_LIST=$(_get_attachments "${INPUT_FILE}")
ATTACHMENT_FILE="$(_maketemp).txt"
echo "${ATTACHMENT_LIST}" > "${ATTACHMENT_FILE}"

_make_field() {
    local KEY="${1}" VALUE_FILE="${2}" MULTI="${3}" RO="${4}"

    # Get custom height if defined, otherwise use default
    local HEIGHT="${FIELD_HEIGHTS[$KEY]:-100}"

    if [[ ! " ${MKV_TAG_SET_NMAAHC[*]} " =~ [[:space:]]${KEY}[[:space:]] ]] ; then
        KEY_LABEL="${KEY}*"
    else
        KEY_LABEL="${KEY}"
    fi

    if [[ -n "${VALUE_FILE}" ]] && [[ -s "${VALUE_FILE}" ]]; then
        INPUT_CMD="<input file>${VALUE_FILE}</input>"
    else
        INPUT_CMD=""
    fi

    if [[ "${RO}" == "yes" ]]; then
        echo "<hbox>
            <hbox width-request=\"200\"><text xalign=\"0\"><label>${KEY_LABEL} [RO]</label></text></hbox>
            <hbox width-request=\"800\">
                <hbox width-request=\"800\">
                    <entry editable=\"false\" sensitive=\"false\">
                        <variable>${KEY}</variable>${INPUT_CMD}
                    </entry>
                </hbox>
            </hbox>
        </hbox>"
    elif [[ "${MULTI}" == "yes" ]]; then
        echo "<hbox>
            <hbox width-request=\"200\"><text xalign=\"0\"><label>${KEY_LABEL}</label></text></hbox>
            <hbox width-request=\"800\">
                <vbox height-request=\"${HEIGHT}\" width-request=\"800\">
                    <edit wrap-mode=\"1\">
                        <variable>${KEY}</variable>${INPUT_CMD}
                    </edit>
                </vbox>
            </hbox>
        </hbox>"
    else
        echo "<hbox>
            <hbox width-request=\"200\"><text xalign=\"0\"><label>${KEY_LABEL}</label></text></hbox>
            <hbox width-request=\"800\">
                <hbox width-request=\"800\">
                    <entry>
                        <variable>${KEY}</variable>${INPUT_CMD}
                    </entry>
                </hbox>
            </hbox>
        </hbox>"
    fi
}

# Read-Only tags
RO_FIELDS=""
for TAG in "${RO_TAGS[@]}"; do
    TEMP_DIALOG_VALUE="$(_maketemp).txt"
    xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple[Name='${TAG}']" -v "String" "${EXTRACTED_TAGS}" > "${TEMP_DIALOG_VALUE}"
    LINE_COUNT="$(awk 'BEGIN{count=0} {count++} END{print count}' < "${TEMP_DIALOG_VALUE}")"
    if [[ "${LINE_COUNT}" -lt "2" ]] ; then
        RO_FIELDS+="$(_make_field "${TAG}" "${TEMP_DIALOG_VALUE}" "no"  "yes")"
    else
        RO_FIELDS+="$(_make_field "${TAG}" "${TEMP_DIALOG_VALUE}" "yes" "yes")"
    fi
    LIST_OF_KEYS+=("$TAG")
done

# Add ATTACHMENTS field manually
RO_FIELDS+="$(_make_field "ATTACHMENTS" "$ATTACHMENT_FILE" "no" "yes")"
LIST_OF_KEYS+=("ATTACHMENTS")

[[ -n "$RO_FIELDS" ]] && READ_ONLY_LIST+="<text use-markup=\"true\"><label>\"<b><span foreground='purple'>Technical and Hashes</span></b>\"</label></text>${RO_FIELDS}"

while read EXISTING_KEY ; do
    DIALOG_LIST+="${EXISTING_KEY} "
    _in_list "${EXISTING_KEY}" "${RO_TAGS[@]}" && continue
    [[ "${EXISTING_KEY}" == "ATTACHMENTS" ]] && continue
    TEMP_DIALOG_VALUE="$(_maketemp).txt"
    xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple[Name='${EXISTING_KEY}']" -v "String" "${EXTRACTED_TAGS}" > "${TEMP_DIALOG_VALUE}"
    LINE_COUNT="$(awk 'BEGIN{count=0} {count++} END{print count}' < "${TEMP_DIALOG_VALUE}")"
    
    LIST_OF_KEYS+=("${EXISTING_KEY}")
    if [[ "${LINE_COUNT}" -lt "2" ]] ; then
        DIALOG_LIST_EMBEDDED+="$(_make_field "${EXISTING_KEY}" "${TEMP_DIALOG_VALUE}" "no"  "no")"
    else
        DIALOG_LIST_EMBEDDED+="$(_make_field "${EXISTING_KEY}" "${TEMP_DIALOG_VALUE}" "yes" "no")"
    fi
done < "${EXISTING_TAGS}"

while read EXTRA_KEY ; do
    DIALOG_LIST+="${EXTRA_KEY} "
    _in_list "${EXTRA_KEY}" "${RO_TAGS[@]}" && continue
    _in_list "${EXTRA_KEY}" "${MKV_TAG_SET_NMAAHC[@]}" && continue
    [[ "${EXTRA_KEY}" == "ATTACHMENTS" ]] && continue
    TEMP_DIALOG_VALUE="$(_maketemp).txt"
    xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple[Name='${EXTRA_KEY}']" -v "String" "${EXTRACTED_TAGS}" > "${TEMP_DIALOG_VALUE}"
    LINE_COUNT="$(awk 'BEGIN{count=0} {count++} END{print count}' < "${TEMP_DIALOG_VALUE}")"
    
    LIST_OF_KEYS+=("${EXTRA_KEY}")
    if [[ "${LINE_COUNT}" -lt "2" ]] ; then
        DIALOG_LIST_EXTRA+="$(_make_field "${EXTRA_KEY}" "${TEMP_DIALOG_VALUE}" "no"  "no")"
    else
        DIALOG_LIST_EXTRA+="$(_make_field "${EXTRA_KEY}" "${TEMP_DIALOG_VALUE}" "yes" "no")"
    fi
done < "${EXISTING_TAGS}"

for TAG in "${MKV_TAG_SET_NMAAHC[@]}" ; do
    KEY="${TAG%%=*}"
    MULTI=$(_in_list "$TAG" "${MULTILINE_TAGS[@]}" && echo "yes" || echo "no")
    if [[ ! " ${DIALOG_LIST[*]} " =~ [[:space:]]${TAG}[[:space:]] ]] ; then
        LIST_OF_KEYS+=("${TAG}")
        DIALOG_LIST_SET+="$(_make_field "${TAG}" "" "${MULTI}"  "no")"
    fi 
done

echo '
style "bgWhite" { bg[NORMAL] = "#FFFFFF" }
style "fgWhite" { fg[NORMAL] = "white"  font_name = "Mono 16"}
style "fgBlack" { fg[NORMAL] = "black" }
style "bgMain" { bg[NORMAL] = "#671E75" }
style "bgRed" { bg[NORMAL] = "red" }
style "fgRed" { fg[NORMAL] = "red" }
style "bgGreen" { bg[NORMAL] = "#BB55BB" }
style "fgGreen" { fg[NORMAL] = "green" }
style "bgBlue" { bg[NORMAL] = "#0000FF" }
style "fgBlue" { fg[NORMAL] = "#0000FF" }
style "custom-font" { font_name = "Sans 64" }

widget "mkvnotemain" style "bgMain"

widget_class "*GtkLabel" style "fgWhite"
widget_class "*.GtkLabel" style "fgWhite"

' > /tmp/gtkrc_mono
export GTK2_RC_FILES=/tmp/gtkrc_mono

DIALOG_FORM="$(_maketemp).xml"
cat > "${DIALOG_FORM}" <<EOF
<window title="Welcome to NMAAHC mkvnote - Matroska Metadata Editor!" default-width="1100" default-height="700" name="mkvnotemain">
    <vbox>
        <text xalign="0" width-request="1000">
            <label>Edit metadata tags. These tags semantically are intended to describe the file as a whole and not intended to specifically refer to a particular track or attachment or other piece of the file. Empty tags will be ignored. If you edit existing tags here, they will be overwritten when saved.</label>
        </text>
        <vbox scrollable="true" height="600" space-expand="true" space-fill="true">
            <text xalign="0" width-request="1000">
                <label>Read-only tags.</label>
            </text>
            ${READ_ONLY_LIST}
            <text xalign="0" width-request="1000">
                <label>Profile metadata tags already embedded.</label>
            </text>
            ${DIALOG_LIST_EMBEDDED}
            <text xalign="0" width-request="1000">
                <label>Non-profile metadata tags already embedded.</label>
            </text>
            ${DIALOG_LIST_EXTRA}
            <text xalign="0" width-request="1000">
                <label>Yet unused metadata tags.</label>
            </text>
            ${DIALOG_LIST_SET}
        </vbox>
        <hbox space-expand="false" space-fill="false">
            <button>
                <label>Settings</label>
                <input file stock="gtk-index"></input>
                <variable export="false">settings_button</variable>
            </button>
            <hbox space-expand="true" space-fill="true">
                <text>
                    <label>""</label>
                </text>
            </hbox>
            <button>
                <label>Tag-On!</label>
                <input file stock="gtk-media-record"></input>
            </button>
            <button cancel></button>
        </hbox>
    </vbox>
</window>
EOF

DIALOG_RESULT="$(export MAIN_DIALOG="$(cat "${DIALOG_FORM}")" ; gtkdialog --center --program MAIN_DIALOG)"
EXIT_STATUS="$(echo "${DIALOG_RESULT}" | grep "^EXIT=" | cut -d= -f2- | sed 's/^"//g;s/"$//g')"

if [[ "${EXIT_STATUS}" == "Cancel" ]] ; then
    echo "Nevermind then o_o ${EXISTING_TAGS}"
    exit
elif [[ "${EXIT_STATUS}" == "Tag-On!" ]] ; then
    echo "<Tags><Tag></Tag></Tags>" > "${XML_DRAFT}"

    READ_MULTILINE=0
    PARSING_COUNTER=0
    TO_BE_PARSED="${#LIST_OF_KEYS[@]}"

    DATA_TO_PARSE="$(echo "${DIALOG_RESULT}" | grep -v "^EXIT=")"

    SORTED_KEYS=($(echo "${LIST_OF_KEYS[@]}" | tr ' ' '\n' | LC_COLLATE=C sort))

    for ((i=0; i<TO_BE_PARSED; i++)); do
        TAG_NAME=${SORTED_KEYS[$i]}
        [[ "${TAG_NAME}" == "ATTACHMENTS" ]] && continue
        if ((i+1 < TO_BE_PARSED)); then
            NEXT_TAG=${SORTED_KEYS[$i+1]}
        else
            NEXT_TAG=""
        fi
        if [[ -z "${NEXT_TAG}" ]]; then
            TAG_VALUE=$(echo "$DATA_TO_PARSE" | awk "/^${TAG_NAME}/ {found=1} found" | sed "s|^${TAG_NAME}=\"||g" | sed '$d' | sed '$s/.$//')
        else
            TAG_VALUE=$(echo "$DATA_TO_PARSE" | awk "/^${TAG_NAME}/,/^${NEXT_TAG}/" | sed "s|^${TAG_NAME}=\"||g" | sed '$d' | sed '$s/.$//')
        fi

        if [[ -n "${TAG_VALUE// /}" ]] ; then
            echo "${TAG_NAME} ... (${TAG_VALUE})"
            xml ed --omit-decl --inplace --subnode "/Tags/Tag[not(Simple/Name='${TAG_NAME}')]" --type elem -n "Simple" --subnode "/Tags/Tag/Simple[not(Name)]" --type elem -n "Name" -v "${TAG_NAME}" --subnode "/Tags/Tag/Simple[not(String)]" --type elem -n "String" -v "$(echo -e "${TAG_VALUE}")" "${XML_DRAFT}"
        fi
    done

    mkvpropedit --tags "global:${XML_DRAFT}" "${INPUT_FILE}"

    cowsay "Cool. Done. Enjoy. Tag-on. ${INPUT_FILE}.${RESET}"
fi
