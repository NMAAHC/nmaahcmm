#!/bin/bash

MKV_TAG_SET_NMAAHC=(
    "COLLECTION"
    "TITLE"
    "CATALOG_NUMBER" 
    "DESCRIPTION"
    "DATE_DIGITIZED"
    "ENCODER_SETTINGS"
    "ENCODED_BY"
    "ORIGINAL_MEDIA_TYPE"
    "DATE_TAGGED"
    "_TAGGED_BY"
    "TERMS_OF_USE"
    "_PRE_TRANSFER_NOTES"
    "_TRANSFER_NOTES"
    "_ORIGINAL_FPS"
)

BOLD=$(tput bold)          # Sets text style to bold for emphasis.
RESET=$(tput sgr0)         # Resets text style to the default, removing any bold or color.
GB=$(tput setaf 38)        # Sets the text color to greenish-blue for regular output.
ERROR=$(tput setaf 1)      # Sets the text color to red for error messages.

_usage(){
    cat <<EOF

    $(basename "${0}")

    This application will embed key:value pairs ("tags") into a Matroska file.
   
    Usage: $(basename "${0}") /path/to/file

    Tag keys are pre-defined:

        COLLECTION
        TITLE
        CATALOG_NUMBER
        DESCRIPTION
        DATE_DIGITIZED
        ENCODER_SETTINGS
        ENCODED_BY
        ORIGINAL_MEDIA_TYPE
        DATE_TAGGED
        _TAGGED_BY
        TERMS_OF_USE
        _PRE_TRANSFER_NOTES
        _TRANSFER_NOTES
        _ORIGINAL_FPS

    The filename should be the full path of the file.

    Usage: $(basename "${0}") mycsv.csv

    Other options:

    -c) matroska input and csv output

        To produce a csv output from a list of mkv files:
        $(basename "${0}") -c file1.mkv file2.mkv file3.mkv > my.csv

        The output can then be edited to write back into the source files with "$(basename "${0}") my.csv"

    -i) print info about each file

        To print information about the global tags in each matroska file:

        $(basename "${0}") -i file1.mkv file2.mkv file3.mkv

    -d) delete the global tags

        This option is mostly used for debugging. It will remove all global tags (except the ffmpeg ENCODER
        tag) from all input mkv files. Warning this is a destructive, irreversible process.


EOF
exit
}

_check_dependencies(){
    DEPS_OK=YES
    while [ "${*}" != "" ] ; do
        DEPENDENCY="${1}"
        if [ ! $(which "${DEPENDENCY}") ] ; then
            echo "This script requires ${DEPENDENCY} to run but it is not installed"
            echo "If you are running ubuntu or debian you might be able to install ${DEPENDENCY} with the following command"
            echo "sudo apt-get install ${DEPENDENCY}"
            echo "If you are running mac you might be able to install ${DEPENDENCY} with the following command"
            echo "brew install ${DEPENDENCY}"
            DEPS_OK=NO
        fi
        shift
    done
    if [[ "${DEPS_OK}" = "NO" ]]; then
        echo "Unmet dependencies"
        echo "Exiting!"
        exit 1
    else
        return 0
    fi
}

_check_dependencies csvprintf xmlstarlet mkvpropedit mkvextract xml2csv

OPTIND=1                   # Initialize the option index to 1, the first command-line argument.
while getopts ":cidh:" opt ; do
    case "${opt}" in
        c) MKV2CSV="Y" ;;                    # If the `-p` option is provided, then mkvnote will make a csv from an input list of Matroska files.
        i) MKVINFO="Y" ;;                    # If the `-i` option is provided, the mkvnote will provide a report about the global tags in each input Matroska file.
        d) MKVGLOBALRM="Y" ;;                # If the `-d` option is provided, mkvnote will remove all global tags from the mkv inputs. Warning this is a destructive process.
        h) _usage ;;                         # If the `-h` option is provided, call the `_usage` function to display usage information and exit.
        :) echo "Option -${OPTARG} requires an argument" ; _usage ;;  # Handle the case where an option requires an argument but none is provided.
        *) echo "bad option -${OPTARG}" ; _usage ;;   # Handle any invalid options by displaying an error message and calling `_usage`.
    esac
done
shift "$((OPTIND-1))"      # Shift the positional parameters so that `$1` points to the first non-option argument.

if [[ "${#}" -eq 0 ]]; then
    _usage
fi

INPUT_FILE="${1}"
EXTENSION="${INPUT_FILE##*.}"

_maketemp(){
    mktemp -q -t "$(basename "${0}")"    # Creates a temporary file with a name based on the script's name.
    if [ "${?}" -ne 0 ]; then            # Checks if the `mktemp` command failed (non-zero exit status).
        # If the temporary file creation fails, an error message is displayed, and the script exits.
        echo "${0}: ${ERROR}Can't create temp file, exiting...${RESET}"
        exit 1
    fi
}

_temprm(){
    RM_FILE="${1}"
    if [[ -f "${RM_FILE}" ]] ; then
        rm "${RM_FILE}"
    fi
}

if [[ "${EXTENSION}" == "csv" ]] ; then
    CSV_XML="$(_maketemp).xml"
    csvprintf -X -f "${INPUT_FILE}" > "${CSV_XML}"
    ELEMENT_LIST="$(xmlstarlet sel -t -m "/csv/row[1]/*" -v "name()" -n "${CSV_XML}")"
    FILENAME_FOUND=0    # Initialize a flag to check if the 'filename' column is present in the CSV.
    echo "Examining the csv: ${CSV_XML}."
    while read ELEMENT_VALUE ; do
        if [[ "${ELEMENT_VALUE//_}" == "filename" ]] ; then
            FILENAME_COLUMN_NAME="${ELEMENT_VALUE}"
            ELEMENT_VALUE="filename"
        fi
        echo "Found ${ELEMENT_VALUE}."  # Output the name of each element found.
        ADDITIONAL_COLUMNS+="_${ELEMENT_VALUE}"   # Append each element name to `ADDITIONAL_COLUMNS` with an underscore prefix.
        if [[ "${ELEMENT_VALUE}" == "filename" ]] ; then
            FILENAME_FOUND=1   # If the element name is 'filename', set the flag to indicate its presence.
        fi
    done < <(echo "${ELEMENT_LIST}")

    if [[ "${FILENAME_FOUND}" = "0" ]] ; then
        echo "${BOLD}${ERROR}Error, $(basename "${INPUT_FILE}") does not contain a column called 'filename'. Exiting.${RESET}"
        exit
    fi

    MISSING_FILE=0    # Initialize a flag to track missing files listed in the CSV.
    REPEATED_FILENAMES="$(xmlstarlet sel -t -m "/csv/row/___filename" -v . -n  "${CSV_XML}" | sort | uniq -c | grep -v "^ *1 ")"
    if [[ -n "${REPEATED_FILENAMES}" ]] ; then
        echo "${BOLD}${ERROR}Error, ${INPUT_FILE} contains multiple iterations of the same filename.${RESET}"
        echo "${REPEATED_FILENAMES}"
        echo "${BOLD}${ERROR}Comee back when it's fixed.${RESET}"
        exit 1
    fi
    ROW_COUNTER=1 # just a counter for when we need to communicate what row we're processing while going through the csv
    while read FILE_IN_CSV ; do
        ((ROW_COUNTER++))
        if [[ -z "${FILE_IN_CSV}" ]] ; then
            echo "${BOLD}${ERROR}Warning, the filename column on row ${ROW_COUNTER} is empty.${RESET}"
        elif [[ ! -f "${FILE_IN_CSV}" ]] ; then
            echo "${BOLD}${ERROR}Error, $(basename "${FILE_IN_CSV}") is referenced in the csv but not found.${RESET}"
            MISSING_FILE=1
            MISSING_FILE_LIST+="${FILE_IN_CSV} "  # Append the missing file name to the list of missing files.
        fi
    done < <(xmlstarlet sel -t -m "/csv/row/${FILENAME_COLUMN_NAME}" -v . -n "${CSV_XML}")
    if [[ -z "${FILENAME_COLUMN_NAME}" ]] ; then
        FILENAME_COLUMN_NAME="filename"
    fi
    if [[ "${MISSING_FILE}" != "0" ]] ; then
        echo "${BOLD}${ERROR}Error, Some files in the csv, such as ${MISSING_FILE_LIST}, are not found. Exiting.${RESET}"
        exit
    else
        echo "${BOLD}Nice. All files from the csv are found. Let's tag.${RESET}"
    fi
    while read FILE_IN_CSV ; do
        XML_DRAFT="$(_maketemp).xml"
        mkvextract tags "${FILE_IN_CSV}" > "${XML_DRAFT}"
        EXISTING_TAGS="$(xmlstarlet sel -t -m '/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple/Name' -v . -n "${XML_DRAFT}" | awk '!seen[$0]++')"
        echo "${BOLD}Tagging ${FILE_IN_CSV} with: ${RESET}"
        echo "---------------------|---------------------"

        while read TAG_NAME ; do
            TAG_VALUE="$(xmlstarlet sel -t -m "/csv/row[${FILENAME_COLUMN_NAME}='${FILE_IN_CSV}']/${TAG_NAME}" -v "." -n "${CSV_XML}")"
            if [[ "${TAG_NAME//_}" == "filename" ]] ; then
                TAG_NAME="filename"
            fi

            if ! xmlstarlet sel -t -m '/Tags/Tag[not(Targets) or count(Targets/*)=0]' -v '.' -n "${XML_DRAFT}" | grep -q . ; then
              xmlstarlet ed -P -L \
                -s '/Tags' -t elem -n 'Tag' \
                -s '/Tags/Tag[last()]' -t elem -n 'Targets' \
                "${XML_DRAFT}"
              echo "Added a new <Tag> with empty <Targets> with ${FILE_IN_CSV}."
            fi

            if [[ -n "${TAG_VALUE// /}" && "${TAG_NAME//_}" != "filename" ]] ; then
                if echo "${EXISTING_TAGS}" | grep -Fxq "${TAG_NAME}"; then
                    xml ed --omit-decl -P --inplace \
                        --update "(/Tags/Tag[Simple/Name='${TAG_NAME}'])[last()]/Simple[Name='${TAG_NAME}']/String" -v "${TAG_VALUE}" \
                        "${XML_DRAFT}"
                else
                    xml ed --omit-decl --inplace \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]" --type elem -n "Simple" \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple[not(Name)]" --type elem -n "Name" -v "${TAG_NAME}" \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple[not(String)]" --type elem -n "String" -v "${TAG_VALUE}" \
                        "${XML_DRAFT}"
                fi
            fi
            printf "%-22s" "$TAG_NAME"
            echo "$TAG_VALUE" | sed '1n; s/^/                      /'

        done < <(xmlstarlet sel -t -m "/csv/row[${FILENAME_COLUMN_NAME}='${FILE_IN_CSV}']/*[normalize-space(.) != '']" -v "name()" -n "${CSV_XML}")


        echo  # Add an empty line for better readability in the output.

        mkvpropedit --tags "all:${XML_DRAFT}" "${FILE_IN_CSV}"

    done < <(xmlstarlet sel -t -m "/csv/row/${FILENAME_COLUMN_NAME}" -v . -n "${CSV_XML}")

    exit

    DIALOG_FORM="$(_maketemp).xml"
    DIALOG_RESULT="$(dialog --jsonfile "${DIALOG_FORM}")"
    echo $DIALOG_RESULT
    exit
fi

if [[ "${MKV2CSV}" == "Y" ]] ; then
    INPUT_FILES=("$@")
    while [[ "${@}" != "" ]] ; do
        INPUT_FILE="${1}"
        shift
        EXTRACTED_TAGS="$(_maketemp).xml"
        XML_DRAFT="$(_maketemp).xml"
        mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
        TAGS_FOUND+="$(xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple" -v "Name" -n "${EXTRACTED_TAGS}")"$'\n'
    done
    UNIQUE_TAGS="$(awk 'NF && !seen[$0]++' <<< "$TAGS_FOUND")"

    CSV_XML="$(_maketemp).xml"
    echo "<csv/>" > "${CSV_XML}"
    for INPUT_FILE in "${INPUT_FILES[@]}"; do
        XML_ED_INSTRUCTIONS=()
        EXTRACTED_TAGS="$(_maketemp).xml"
        mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
        while read UNIQUE_TAG ; do
            UNIQUE_TAG_VALUE="$(xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple[Name='${UNIQUE_TAG}']" -v "String" -n "${EXTRACTED_TAGS}")"
            if [[ "${UNIQUE_TAG}" == "${UNIQUE_TAG// /}" ]] ; then
                XML_ED_INSTRUCTIONS+=(--subnode "/csv/row[not(${UNIQUE_TAG})]" --type elem -n "${UNIQUE_TAG}" -v "${UNIQUE_TAG_VALUE}")
            else
                echo "${BOLD}${ERROR}Warning, ${INPUT_FILE} contains a TagName of '${UNIQUE_TAG}'; however TagName is not allowed to contain a space. This value will be ignored while making the csv. See ${EXTRACTED_TAGS} for the tag structure of this file if you like.${RESET}" >&2
            fi
        done <<< "${UNIQUE_TAGS}"

        xml ed --omit-decl --inplace \
            --subnode "/csv" --type elem -n "row" \
            --subnode "/csv/row[not(filename)]" --type elem -n "filename" -v "${INPUT_FILE}" "${XML_ED_INSTRUCTIONS[@]}" "${CSV_XML}"
        EXTRACTED_TAGS="$(_maketemp).txt"
        XML_DRAFT="$(_maketemp).xml"
    done
    CSV_HEADER=$(xmlstarlet sel -t -m "/csv/row[1]/*" -v "name()" -o "," "${CSV_XML}" | sed 's/,$//')
    echo "${CSV_HEADER}"
    xml2csv "${CSV_XML}"
    exit
fi

if [[ "$MKVINFO" == "Y" ]] ; then
    INPUT_FILES=("$@")
    while [[ "${@}" != "" ]] ; do
        # get context about the input
        INPUT_FILE="${1}"
        shift
        echo "Global tag report for: ${INPUT_FILE}"
        echo "---------------------|---------------------"
        mkvextract tags "${INPUT_FILE}" | xmlstarlet sel -t -m "Tags/Tag[not(Targets) or count(Targets/*)=0]" -m Simple  -v Name -o $'\t' -v String -o $'\037' | awk -v RS=$'\037' -F'\t' '{n = split($2, lines, /\r?\n/); printf "%-21s %s\n", $1, lines[1]; for(i=2; i<=n; i++) printf "%-21s %s\n", "", lines[i]; }' 
        mkvextract tags "${INPUT_FILE}" | xmlstarlet sel -t -m "Tags/Tag[not(Targets) or count(Targets/*)=0]" -o "Tag:" -n  -m Simple -o " " -v Name -o "=(" -v String -o ")" -n 
        echo
    done
    exit
fi

if [[ "$MKVGLOBALRM" == "Y" ]] ; then
    INPUT_FILES=("$@")
    echo "This process will delete all the global tags in all the input files. Are you sure? Type 'Y' to proceed, anything else to quit."
    read -p "Really? " DELETE_CHOICE
    if [[ "${DELETE_CHOICE}" =~ ^[Yy]$ ]] ; then
        while [[ "${@}" != "" ]] ; do
            # get context about the input
            INPUT_FILE="${1}"
            shift
            echo "Deleting global tags for ${INPUT_FILE}..."
            TEMP_XML="$(_maketemp).xml"
            mkvextract tags out2.mkv | xmlstarlet ed -d "//Tag[Targets/*]" -d '//Simple[Name != "ENCODER"]' > "${TEMP_XML}"
            mkvpropedit --tags "global:" "${INPUT_FILE}"
            mkvpropedit --tags "global:${TEMP_XML}" "${INPUT_FILE}"
        done
        _temprm "${TEMP_XML}"
        echo "Thx. Global tags are gone now from $(basename "${INPUT_FILE}")."
    else
        echo "np"
    fi
    exit
fi

EXISTING_TAGS="$(_maketemp).txt"
EXTRACTED_TAGS="$(_maketemp).txt"
XML_DRAFT="$(_maketemp).xml"

mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple" -v "Name" -n "${EXTRACTED_TAGS}" >> "${EXISTING_TAGS}"

while read EXISTING_KEY ; do
    DIALOG_LIST+="${EXISTING_KEY} "
    if [[ ! ${MKV_TAG_SET_NMAAHC[*]} =~ "\"${EXISTING_KEY}\"" ]] ; then
        TEMP_DIALOG_VALUE="$(_maketemp).txt"
        xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple[Name='${EXISTING_KEY}']" -v "String" "${EXTRACTED_TAGS}" > "${TEMP_DIALOG_VALUE}"
        LINE_COUNT="$(awk 'BEGIN{count=0} {count++} END{print count}' < "${TEMP_DIALOG_VALUE}")"
        if [[ ! " ${MKV_TAG_SET_NMAAHC[*]} " =~ [[:space:]]${EXISTING_KEY}[[:space:]] ]] ; then
            KEY_LABEL="${EXISTING_KEY}*"
        else
            KEY_LABEL="${EXISTING_KEY}"
        fi
        LIST_OF_KEYS+=("${EXISTING_KEY}")
        if [[ "${LINE_COUNT}" -lt "2" ]] ; then
            DIALOG_LIST_EMBEDDED+="
                    <hbox>
                        <hbox width-request=\"200\">
                            <text xalign=\"0\">
                                <label>${KEY_LABEL}</label>
                            </text>
                        </hbox>
                        <hbox width-request=\"800\">
                            <entry width=\"700\">
                                <variable>${EXISTING_KEY}</variable>
                                <input file>${TEMP_DIALOG_VALUE}</input>
                                <action signal=\"show\">refresh:${EXISTING_KEY}</action>
                            </entry>
                        </hbox>
                    </hbox>"
        else
            DIALOG_LIST_EMBEDDED+="
                <hbox>
                    <hbox width-request=\"200\">
                        <text xalign=\"0\">
                            <label>${KEY_LABEL}</label>
                        </text>
                    </hbox>
                    <hbox width-request=\"800\">
                        <edit width=\"700\" wrap-mode=\"1\">
                            <variable>${EXISTING_KEY}</variable>
                            <input file>${TEMP_DIALOG_VALUE}</input>
                            <action signal=\"show\">refresh:${EXISTING_KEY}</action>
                        </edit>
                    </hbox>
                </hbox>"
        fi
    fi
    
done < "${EXISTING_TAGS}"

for TAG in "${MKV_TAG_SET_NMAAHC[@]}" ; do
    KEY="${TAG%%=*}"
    if [[ ! " ${DIALOG_LIST[*]} " =~ [[:space:]]${TAG}[[:space:]] ]] ; then
        LIST_OF_KEYS+=("${TAG}")
        DIALOG_LIST_SET+="
                <hbox>
                    <hbox width-request=\"200\">
                        <text xalign=\"0\">
                            <label>${KEY}</label>
                        </text>
                    </hbox>
                    <hbox width-request=\"800\">
                        <entry width=\"700\">
                            <variable>${KEY}</variable>
                        </entry>
                    </hbox>
                </hbox>"
    fi 
done

echo '
style "bgWhite" { bg[NORMAL] = "#FFFFFF" }
style "fgWhite" { fg[NORMAL] = "white"  font_name = "Mono 16"}
style "fgBlack" { fg[NORMAL] = "black" }
style "bgMain" { bg[NORMAL] = "#671E75" }
style "bgRed" { bg[NORMAL] = "red" }
style "fgRed" { fg[NORMAL] = "red" }
style "bgGreen" { bg[NORMAL] = "#BB55BB" }
style "fgGreen" { fg[NORMAL] = "green" }
style "bgBlue" { bg[NORMAL] = "#0000FF" }
style "fgBlue" { fg[NORMAL] = "#0000FF" }
style "custom-font" { font_name = "Sans 64" }

widget "mkvnotemain" style "bgMain"

widget_class "*GtkLabel" style "fgWhite"
widget_class "*.GtkLabel" style "fgWhite"

' > /tmp/gtkrc_mono
export GTK2_RC_FILES=/tmp/gtkrc_mono

DIALOG_FORM="$(_maketemp).xml"

cat << EOF > "${DIALOG_FORM}"
<window title="Welcome to mkvnote!" default-width="1100" name="mkvnotemain">
    <vbox>
        <text xalign="0" width-request="1000">
            <label>These tags semantically are intended to describe the file as a whole and not intended to specifically refer to a particular track or attachment or other sort of piece of the file. Empty tags will be ignored. If you edit exisitng tags here they will be overwritten when saved.</label>
        </text>
        <vbox scrollable="true" height="600" space-expand="true" space-fill="true">
            <text xalign="0" width-request="1000">
                <label>Metadata tags already embedded.</label>
            </text>
            ${DIALOG_LIST_EMBEDDED}
            <text xalign="0" width-request="1000">
                <label>Yet unused metadata tags.</label>
            </text>
            ${DIALOG_LIST_SET}
        </vbox>
        <hbox space-expand="false" space-fill="false">
            <button>
                <label>Settings</label>
                <input file stock="gtk-index"></input>
                <variable export="false">settings_button</variable>
            </button>
            <hbox space-expand="true" space-fill="true">
                <text>
                    <label>""</label>
                </text>
            </hbox>
            <button>
                <label>Tag-On!</label>
                <input file stock="gtk-media-record"></input>
                <variable export="false">record_button</variable>
            </button>
            <button cancel>
            </button>
        </hbox>
    </vbox>
</window>
EOF

DIALOG_RESULT="$(export MAIN_DIALOG="$(cat "${DIALOG_FORM}")" ; gtkdialog --center --program MAIN_DIALOG)"
EXIT_STATUS="$(echo "${DIALOG_RESULT}" | grep "^EXIT=" | cut -d= -f2- | sed 's/^"//g;s/"$//g')"

if [[ "${EXIT_STATUS}" == "Cancel" ]] ; then
    echo "Nevermind then o_o ${EXISTING_TAGS}"
    exit
elif [[ "${EXIT_STATUS}" == "Tag-On!" ]] ; then
    echo "<Tags><Tag></Tag></Tags>" > "${XML_DRAFT}"

    READ_MULTILINE=0
    PARSING_COUNTER=0
    TO_BE_PARSED="${#LIST_OF_KEYS[@]}"

    DATA_TO_PARSE="$(echo "${DIALOG_RESULT}" | grep -v "^EXIT=")"

    SORTED_KEYS=($(echo "${LIST_OF_KEYS[@]}" | tr ' ' '\n' | sort))

    for ((i=0; i<TO_BE_PARSED; i++)); do
        TAG_NAME=${SORTED_KEYS[$i]}
        if ((i+1 < TO_BE_PARSED)); then
            NEXT_TAG=${SORTED_KEYS[$i+1]}
        else
            NEXT_TAG=""
        fi
        if [[ -z "${NEXT_TAG}" ]]; then
            TAG_VALUE=$(echo "$DATA_TO_PARSE" | awk "/^${TAG_NAME}/ {found=1} found" | sed "s|^${TAG_NAME}=\"||g" | sed '$d' | sed '$s/.$//')
        else
            TAG_VALUE=$(echo "$DATA_TO_PARSE" | awk "/^${TAG_NAME}/,/^${NEXT_TAG}/" | sed "s|^${TAG_NAME}=\"||g" | sed '$d' | sed '$s/.$//')
        fi

        if [[ -n "${TAG_VALUE// /}" ]] ; then
            echo "${TAG_NAME} ... (${TAG_VALUE})"
            xml ed --omit-decl --inplace --subnode "/Tags/Tag[not(Simple/Name='${TAG_NAME}')]" --type elem -n "Simple" --subnode "/Tags/Tag/Simple[not(Name)]" --type elem -n "Name" -v "${TAG_NAME}" --subnode "/Tags/Tag/Simple[not(String)]" --type elem -n "String" -v "$(echo -e "${TAG_VALUE}")" "${XML_DRAFT}"
        fi
    done

    mkvpropedit --tags "global:${XML_DRAFT}" "${INPUT_FILE}"

    cowsay "Cool. Done. Enjoy. Tag-on. ${INPUT_FILE}.${RESET}"
fi
